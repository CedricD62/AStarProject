package pathFinding;

public class Gridania 
{

	public static void lancementGridania() {
		
		 // informations de dimention de la matrice
		 int nbrLigneGrille = 17;
		 int nbrColonnesGrille = 14;
		 // coordonnées du points de départ
		 int numLigneDepart = 0;
		 int numColonneDepart = 7;
		 // coordonnées du point d'arrivé
		 int numLigneArrive = 0;
		 int numColonneArrive = 1;
		 // tableau à 2 dimension regroupant les obstacles dans la zone
		 int [][] obstableZone = {{0,0},{0,4},{0,5},{0,6},{0,9},{0,10},{0,11},
								  {1,0},{1,9},{1,10},
								  {2,9},
								  {3,2},{3,3},{3,4},{3,9},{3,13},
								  {4,0},{4,1},{4,3},{4,4},{4,6},{4,7},{4,10},{4,12},{4,13},
								  {5,0},{5,1},{5,3},{5,4},{5,6},{5,7},{5,10},{5,12},{5,13},
								  {6,0},{6,1},{6,2},{6,4},{6,6},{6,8},{6,10},{6,12},{6,13},
								  {7,0},{7,1},{7,2},{7,3},{7,6},{7,9},{7,10},{7,12},{7,12},{7,13},
								  {8,0},{8,1},{8,2},{8,3},{8,9},{8,10},{8,11},{8,13},
								  {9,0},{9,1},{9,2},{9,3},{9,6},{9,9},{9,10},{9,11},{9,13},
								  {10,0},{10,1},{10,2},{10,3},{10,4},{10,5},{10,9},{10,10},{10,11},{10,13},
								  {11,0},{11,1},{11,2},{11,3},{11,4},{11,5},{11,6},{11,7},{11,9},{11,10},{11,11},{11,13},
								  {12,0},{12,1},{12,2},{12,3},{12,4},{12,5},{12,6},{12,7},{12,8},{12,13},
								  {13,0},{13,1},{13,2},{13,3},{13,4},{13,5},{13,6},{13,7},{13,8},{13,9},{13,13},
								  {14,0},{14,1},{14,2},{14,3},{14,4},{14,5},{14,6},{14,7},{14,8},{14,9},{14,12},
								  {15,0},{15,1},{15,2},{15,3},{15,4},{15,5},{15,6},{15,7},{15,8},{15,9},{15,12},{15,13},
								  {16,0},{16,1},{16,2},{16,3},{16,4},{16,5},{16,6},{16,7},{16,8},{16,9},{16,11},{16,12},{16,13}};
		 // tableau à 1 dimension renseignant les nibeai minimum et maximum par case ( block de 2 valeur pour 1 case en partant de la coordonnée "0.0")
		 int [] niveauZone =  { 0,0, 45,50 ,45,50 ,5,10 ,0,0 ,0,0 ,0,0 ,1,1 ,1,1 ,0,0 ,0,0 ,45,50 ,45,50 ,45,50, 
								0,0, 45,50 ,45,50 ,5,10 ,1,1 ,1,1 ,1,1 ,1,1 ,1,1 ,0,0 ,0,0 ,45,50 ,45,50 ,45,50,  
								25,30, 25,30 ,45,50 ,5,10 ,1,1 ,1,1 ,1,1 ,1,1 ,1,1 ,0,0 ,10,15 ,20,25 ,45,50 ,45,50, 
								25,30, 25,30 ,0,0 ,0,0 ,0,0 ,1,1 ,1,1 ,1,1 ,1,1 ,0,0 ,10,15 ,10,15 ,15,20 ,0,0, 
								0,0, 0,0 ,1,1 ,0,0 ,0,0 ,1,1 ,0,0 ,0,0 ,1,1 ,1,1 ,0,0 ,1,1 ,0,0 ,0,0, 
								0,0, 0,0 ,1,1 ,0,0 ,0,0 ,1,1 ,0,0 ,0,0 ,1,1 ,1,1 ,0,0 ,1,1 ,0,0 ,0,0, 
								0,0, 0,0 ,0,0 ,1,1 ,0,0 ,1,1 ,0,0 ,1,1 ,0,0 ,1,1 ,0,0 ,1,1 ,0,0 ,0,0, 
								0,0, 0,0 ,0,0 ,0,0 ,30,35 ,30,35 ,0,0 ,1,5 ,1,5 ,0,0 ,0,0 ,1,1 ,0,0 ,0,0, 
								0,0, 0,0 ,0,0 ,0,0 ,30,35 ,30,35 ,30,35 ,5,10 ,5,10 ,0,0 ,0,0 ,0,0 ,1,1 ,0,0, 
								0,0, 0,0 ,0,0 ,0,0 ,30,35 ,30,35 ,0,0 ,10,15 ,5,10 ,0,0 ,0,0 ,0,0 ,1,1 ,0,0, 
								0,0, 0,0 ,0,0 ,0,0 ,0,0 ,0,0 ,10,15 ,10,15 ,10,15 ,0,0 ,0,0 ,0,0 ,1,1 ,0,0, 
								0,0, 0,0 ,0,0 ,0,0 ,0,0 ,0,0 ,0,0 ,0,0 ,1,1 ,0,0 ,0,0 ,0,0 ,1,1 ,0,0, 
								0,0, 0,0 ,0,0 ,0,0 ,0,0 ,0,0 ,0,0 ,0,0 ,0,0 ,20,25 ,20,25 ,25,30 ,20,25 ,0,0, 
								0,0, 0,0 ,0,0 ,0,0 ,0,0 ,0,0 ,0,0 ,0,0 ,0,0 ,0,0 ,20,25 ,25,30 ,20,25 ,0,0, 
								0,0, 0,0 ,0,0 ,0,0 ,0,0 ,0,0 ,0,0 ,0,0 ,0,0 ,0,0 ,20,25 ,35,40 ,0,0 ,40,45, 
								0,0, 0,0 ,0,0 ,0,0 ,0,0 ,0,0 ,0,0 ,0,0 ,0,0 ,0,0 ,30,35 ,30,35 ,0,0 ,0,0, 
								0,0, 0,0 ,0,0 ,0,0 ,0,0 ,0,0 ,0,0 ,0,0 ,0,0 ,0,0 ,30,35 ,0,0 ,0,0 ,0,0};
		// les informations sont insérées dans le constructeur Methode pour le lancement de d'A*
		Methodes aStar = new Methodes(nbrLigneGrille,nbrColonnesGrille,numLigneDepart,numColonneDepart,numLigneArrive,numColonneArrive,obstableZone,niveauZone);
		
		// lancement des différentes méthodes de traitement
		aStar.affichageMatrice();  // affichage de la matrice
		aStar.algorithme();        // application de l'algorithme
		aStar.affichageCoutCase(); // affichage des coûts de déplacements 
		aStar.affichageChemin();   // affichage de la solution		
		}	
}
